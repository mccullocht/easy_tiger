use std::{io, num::NonZero, sync::Arc};

use clap::Args;
use easy_tiger::{
    spann::{
        centroid_stats::CentroidStats,
        rebalance::{merge_centroid, split_centroid, BalanceSummary, RebalanceStats},
        TableIndex,
    },
    vamana::wt::SessionGraphVectorIndex,
};
use rand::SeedableRng;
use wt_mdb::{session::TransactionGuard, Connection};

use crate::ui::progress_spinner;

#[derive(Args)]
pub struct RebalanceArgs {
    /// Number of rebalancing iterations to perform.
    #[arg(long, default_value_t = NonZero::new(1).unwrap())]
    iterations: NonZero<usize>,

    /// If true, commit the transaction generated by rebalancing operations.
    #[arg(long, default_value_t = false)]
    commit: bool,

    /// Random seed used for clustering computations.
    /// Use a fixed value for repeatability.
    #[arg(long, default_value_t = 0x7774_7370414E4E)]
    seed: u64,
}

fn print_balance_summary(summary: &BalanceSummary) {
    println!("SUMMARY");
    println!("  total:        {:6}", summary.total_clusters());
    println!(
        "  in bounds:    {:6} {:5.2}%",
        summary.in_bounds(),
        summary.in_policy_fraction() * 100.0
    );
    println!(
        "  below bounds: {:6} examplar {:?}",
        summary.below_bounds(),
        summary.below_exemplar()
    );
    println!(
        "  above bounds: {:6} exemplar {:?}",
        summary.above_bounds(),
        summary.above_exemplar()
    );
}

pub fn rebalance(
    connection: Arc<Connection>,
    index_name: &str,
    args: RebalanceArgs,
) -> io::Result<()> {
    // TODO: store rng state in the index. Requires rand_xoshiro serde feature.
    let index = Arc::new(TableIndex::from_db(&connection, index_name)?);
    assert_eq!(
        index.config().replica_count,
        1,
        "rebalance only implemented for replica count 1"
    );

    let session = connection.open_session()?;
    let head_index = SessionGraphVectorIndex::new(Arc::clone(index.head_config()), session);
    let mut rng = rand_xoshiro::Xoshiro256PlusPlus::seed_from_u64(args.seed);

    let progress = if args.commit {
        Some(progress_spinner("rebalancing"))
    } else {
        None
    };
    let mut rebalance_stats = RebalanceStats::default();
    for _ in 0..args.iterations.get() {
        let txn_guard = TransactionGuard::new(head_index.session(), None)?;
        let stats = CentroidStats::from_index_stats(head_index.session(), &index)?;
        let summary = BalanceSummary::new(&stats, index.config().centroid_len_range());

        if let Some(ref progress) = progress {
            progress.set_message(format!(
                "rebalancing {}/{} {:.2}% clusters in policy",
                summary.in_bounds(),
                summary.total_clusters(),
                summary.in_policy_fraction() * 100.0
            ));
        }

        match (summary.below_exemplar(), summary.above_exemplar()) {
            (None, None) => {
                break;
            }
            (Some((to_merge, _)), _) => {
                rebalance_stats += merge_centroid(&index, &head_index, to_merge)?;
            }
            (_, Some((to_split, _))) => {
                rebalance_stats += split_centroid(
                    &index,
                    &head_index,
                    to_split,
                    stats.available_centroid_ids().next().unwrap(),
                    &mut rng,
                )?;
            }
        }

        if let Some(ref progress) = progress {
            txn_guard.commit(None)?;
            progress.inc(1);
        } else {
            break; // only ever one iteration if not committing.
        }
    }

    if let Some(progress) = progress {
        let stats = CentroidStats::from_index_stats(head_index.session(), &index)?;
        let summary = BalanceSummary::new(&stats, index.config().centroid_len_range());
        progress.set_message(format!(
            "rebalancing {}/{} {:.2}% clusters in policy",
            summary.in_bounds(),
            summary.total_clusters(),
            summary.in_policy_fraction() * 100.0
        ));
        progress.finish_using_style();
    }
    let stats = CentroidStats::from_index_stats(head_index.session(), &index)?;
    let summary = BalanceSummary::new(&stats, index.config().centroid_len_range());
    if summary.in_policy_fraction() < 1.0 {
        print_balance_summary(&summary);
    }

    println!("Merged:         {:10}", rebalance_stats.merged);
    if rebalance_stats.merged > 0 {
        println!(
            "  Moved:        {:10}",
            rebalance_stats.merge_stats.moved_vectors
        );
    }
    println!("Split:          {:10}", rebalance_stats.split);
    if rebalance_stats.split > 0 {
        println!(
            "  Moved:        {:10}",
            rebalance_stats.split_stats.moved_vectors
        );
        println!(
            "  Searches:     {:10}",
            rebalance_stats.split_stats.searches
        );
        println!(
            "  Nearby seen:  {:10}",
            rebalance_stats.split_stats.nearby_seen
        );
        println!(
            "  Nearby moved: {:10}",
            rebalance_stats.split_stats.nearby_moved
        );
    }

    Ok(())
}
