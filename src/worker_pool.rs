use std::sync::Arc;

use thread_local::ThreadLocal;
use threadpool::ThreadPool;
use wt_mdb::{Connection, Session};

struct SessionSupplier {
    connection: Arc<Connection>,
    session: ThreadLocal<Session>,
}

impl SessionSupplier {
    fn new(connection: Arc<Connection>) -> Self {
        Self {
            connection,
            session: ThreadLocal::new(),
        }
    }

    fn get(&self) -> &Session {
        self.session.get_or(|| {
            self.connection
                .open_session()
                .expect("could not open a new session, perhaps session_max is too low?")
        })
    }
}

/// A worker pool for WiredTiger tasks. Each thread in the pool keeps a cached session that can be
/// used by any clsoure executed on the pool.
// TODO: should this be in the wt_mdb crate?
#[derive(Clone)]
pub struct WorkerPool {
    thread_pool: ThreadPool,
    supplier: Arc<SessionSupplier>,
}

impl WorkerPool {
    /// Create a new pool backed by `thread_pool` with sessions generated by `connection`.
    pub fn new(thread_pool: ThreadPool, connection: Arc<Connection>) -> Self {
        Self {
            thread_pool,
            supplier: Arc::new(SessionSupplier::new(connection)),
        }
    }

    /// Execute the passed closure with the local session for the current thread.
    pub fn execute<C>(&self, closure: C)
    where
        C: FnOnce(&Session) + Send + Sync + 'static,
    {
        let supplier = self.supplier.clone();
        self.thread_pool.execute(move || closure(supplier.get()));
    }
}
